{"id":"be5003ad-c5b3-4a7a-ab02-1596ce70c700","zed":"context","version":"0.4.0","text":"\n\n\nCan you look over this file\n```go silverbadger/main.go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"image\"\n\t\"image/png\"\n\t\"math/rand/v2\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/kolesa-team/go-webp/encoder\"\n\t\"github.com/kolesa-team/go-webp/webp\"\n\n\t\"github.com/charmbracelet/log\"\n\n\t\"github.com/h2non/bimg\"\n\n\t\"github.com/oliamb/cutter\"\n\n\t\"silverbadger/inits\"\n\t\"silverbadger/models\"\n\n\t\"github.com/lib/pq\"\n\n\t\"github.com/aws/aws-sdk-go/aws\"\n\t\"github.com/aws/aws-sdk-go/aws/awsutil\"\n\t\"github.com/aws/aws-sdk-go/aws/credentials\"\n\t\"github.com/aws/aws-sdk-go/aws/session\"\n\t\"github.com/aws/aws-sdk-go/service/s3\"\n)\n\nfunc init() {\n\tinits.LoadEnv()\n\tinits.InitDB()\n}\n\nfunc main() {\n\tuploadCount := 0\n\tpdfCount := 0\n\tpngCount := 0\n\taiCount := 0\n\t// teams is a folder in the root directory, that holds folders per team\n\tteams, _ := os.ReadDir(\"teams\")\n\n\tfor _, team := range teams {\n\t\t// each team is a folder with several folders inside, one of which is exports, which is the folder we need\n\t\tif team.IsDir() {\n\t\t\tlog.Infof(\"twas directory - %v\\n\", team.Name())\n\n\t\t\t// this folder is what we will look through in every team folder, which holds additional folders\n\t\t\tteamDir, _ := os.ReadDir(\"teams/\" + team.Name() + \"/export\")\n\n\t\t\t// declare each variable that will be assigned below as we process the files\n\t\t\tvar pngCdn string\n\t\t\tvar pngCdnFull string\n\t\t\tvar pdfCdn string\n\t\t\tvar aiCdn string\n\t\t\tvar pdfDescription string\n\t\t\tvar sport string\n\t\t\tvar color string\n\t\t\tvar pdfText string\n\t\t\tvar fileName string\n\n\t\t\t// right here, grab the mockup.ai if it exists, to upload with the rest of the goodies\n\t\t\tfindTheMockupDir, _ := os.ReadDir(\"teams/\" + team.Name())\n\t\t\tfor _, item := range findTheMockupDir {\n\t\t\t\tif item.Name() == \"mockup.ai\" {\n\t\t\t\t\taiCdn = processAi(team.Name(), \"mockup\")\n\t\t\t\t\taiCount++\n\t\t\t\t} else if item.Name() == \"mockups.ai\" {\n\t\t\t\t\taiCdn = processAi(team.Name(), \"mockups\")\n\t\t\t\t\taiCount++\n\t\t\t\t} else if item.Name() == \"Mockup.ai\" {\n\t\t\t\t\taiCdn = processAi(team.Name(), \"Mockup\")\n\t\t\t\t\taiCount++\n\t\t\t\t} else if item.Name() == \"Mockups.ai\" {\n\t\t\t\t\taiCdn = processAi(team.Name(), \"Mockups\")\n\t\t\t\t\taiCount++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor _, item := range teamDir {\n\t\t\t\tlog.Infof(\"the item in the team folder - %v\", item.Name())\n\t\t\t\t// assign a team id to tie all the pngs together\n\t\t\t\t// need to get a unique 7 digit number\n\t\t\t\tteamId := 1000000 + rand.IntN(9000000)\n\n\t\t\t\t// sub items will be each of the items within the directories inside the export folder\n\t\t\t\tsubitems, _ := os.ReadDir(\"teams/\" + team.Name() + \"/export/\" + item.Name())\n\t\t\t\tpdfDir, _ := os.ReadDir(\"teams/\" + team.Name() + \"/export/PDF\")\n\n\t\t\t\tfor _, subitem := range subitems {\n\t\t\t\t\t// so these sub items should be files inside the folders inside the export folder\n\t\t\t\t\t// so they will be almost entirely pdf's and png's, with a few ai files here and there\n\t\t\t\t\tlog.Warnf(\"in sub items, is %v\", subitem.Name())\n\n\t\t\t\t\t// if there is another directory inside the sub item, skip it, we don't need it\n\t\t\t\t\tif subitem.IsDir() {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// if you get here, you're inside one of the folders inside the export folder\n\t\t\t\t\t\t// we want to start the process with a found png\n\t\t\t\t\t\t// so everything in this if statement should happen for each png found\n\t\t\t\t\t\tif strings.Contains(subitem.Name(), \".png\") {\n\t\t\t\t\t\t\tlog.Info(\"found a png\")\n\t\t\t\t\t\t\tfileName = strings.TrimSuffix(subitem.Name(), filepath.Ext(subitem.Name()))\n\n\t\t\t\t\t\t\t// process the png, cropping it, uploading it to aws, and getting a cdn link to assign\n\t\t\t\t\t\t\tpngCdn = processPng(team.Name(), item.Name(), fileName)\n\t\t\t\t\t\t\tpngCdnFull = processPngFull(team.Name(), item.Name(), fileName)\n\n\t\t\t\t\t\t\t// create a string to text the pdfs containing, to match up pngs with pdfs\n\t\t\t\t\t\t\tsubitemButSlice := strings.Fields(subitem.Name())\n\t\t\t\t\t\t\tnumberChunk := subitemButSlice[len(subitemButSlice)-1]\n\t\t\t\t\t\t\tprojectNumber := []string{string(numberChunk[0]), string(numberChunk[1]), string(numberChunk[2])}\n\t\t\t\t\t\t\tprojectNumberToMatchAgainst := strings.Join(projectNumber, \"\")\n\t\t\t\t\t\t\tlog.Infof(\"-------- subitem slice here --------- %v\", projectNumberToMatchAgainst)\n\n\t\t\t\t\t\t\t// doing a recursive for range, going through all the files again, this time looking for a pdf\n\t\t\t\t\t\t\t// specifically, we are looking for a pdf that has a matching filename to the png we are currently\n\t\t\t\t\t\t\t// looping on.\n\t\t\t\t\t\t\tfor _, subitemb := range pdfDir {\n\t\t\t\t\t\t\t\tlog.Infof(\"checking against the pdf file named -- %v\", subitemb.Name())\n\t\t\t\t\t\t\t\tif strings.Contains(subitemb.Name(), \".pdf\") && strings.Contains(subitemb.Name(), projectNumberToMatchAgainst) {\n\t\t\t\t\t\t\t\t\t// if we find that related pdf, we are going to process it, getting the text from it\n\t\t\t\t\t\t\t\t\t// and a cdn link to it\n\t\t\t\t\t\t\t\t\tlog.Info(\"found a related pdf\")\n\n\t\t\t\t\t\t\t\t\tpdfCdn, pdfText, pdfDescription, sport, color = processPdf(team.Name(), fileName)\n\n\t\t\t\t\t\t\t\t\tpdfCount++\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpngCount++\n\t\t\t\t\t\t\t// we will upload every single png to the database, hopefully with an associated pdf and text\n\t\t\t\t\t\t\tuploadDesignEntry(fileName, pdfText, pdfDescription, pngCdn, pdfCdn, sport, color, aiCdn, teamId, pngCdnFull)\n\n\t\t\t\t\t\t\tuploadCount++\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlog.Infof(\"Found %v png file(s)\", pngCount)\n\tlog.Infof(\"Found %v pdf file(s)\", pdfCount)\n\tlog.Infof(\"Found %v ai file(s)\", aiCount)\n\tlog.Infof(\"Uploaded %v file(s) to db\", uploadCount)\n}\n\nfunc processPng(teamName string, parentDirName string, fileName string) string {\n\tpathToDir := \"teams/\" + teamName + \"/export/\" + parentDirName + \"/\"\n\n\t// crop and process (compress) the png ============================================= //\n\togImageFile, err := os.Open(pathToDir + fileName + \".png\")\n\t// this is the most common part of the png filename that is not included in the pdf file associated\n\tif err != nil {\n\t\tlog.Warn(err)\n\t}\n\tdefer func(ogImageFile *os.File) {\n\t\terr := ogImageFile.Close()\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"error decoding og image -- %v\", err)\n\t\t}\n\t}(ogImageFile)\n\togImage, err := png.Decode(ogImageFile)\n\tif err != nil {\n\t\tlog.Warnf(\"error decoding og image -- %v\", err)\n\t}\n\n\t// create a copy to work with\n\tcroppedImg, err := cutter.Crop(ogImage, cutter.Config{\n\t\tWidth:  1913,\n\t\tHeight: 1240,\n\t\tAnchor: image.Point{19, 250},\n\t\tMode:   cutter.TopLeft, // optional, default value\n\t})\n\tif err != nil {\n\t\tlog.Warn(\"unable to crop image with cutter\")\n\t}\n\n\tcroppedImageFile, err := os.Create(pathToDir + fileName + \"_copy.png\")\n\tif err != nil {\n\t\tlog.Warnf(\"error closing image cropping -- %v\", err)\n\t}\n\tdefer func(croppedImageFile *os.File) {\n\t\terr := croppedImageFile.Close()\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"error closing image cropping -- %v\", err)\n\t\t}\n\t}(croppedImageFile)\n\n\tif err := png.Encode(croppedImageFile, croppedImg); err != nil {\n\t\tlog.Warn(err)\n\t}\n\n\t// croppedImageFile is what to use going forward\n\t// convert and compress the image\n\tbuffer, err := bimg.Read(pathToDir + fileName + \"_copy.png\")\n\tif err != nil {\n\t\tlog.Warn(err)\n\t}\n\n\tnewImage, err := bimg.NewImage(buffer).Convert(bimg.WEBP)\n\tif err != nil {\n\t\tlog.Warn(err)\n\t}\n\t// convert []byte to image for saving to file\n\tnewImageConv, _, _ := image.Decode(bytes.NewReader(newImage))\n\n\tconvertedImageFile, err := os.Create(pathToDir + fileName + \"_copy_conv.webp\")\n\tif err != nil {\n\t\tlog.Warnf(\"error converting image file to webp -- %v\", err)\n\t}\n\tdefer func(convertedImageFile *os.File) {\n\t\terr := convertedImageFile.Close()\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"error closing image converting -- %v\", err)\n\t\t}\n\t}(croppedImageFile)\n\n\toptions, err := encoder.NewLossyEncoderOptions(encoder.PresetDefault, 75)\n\tif err != nil {\n\t\tlog.Warn(err)\n\t}\n\n\tif err := webp.Encode(convertedImageFile, newImageConv, options); err != nil {\n\t\tlog.Warn(err)\n\t}\n\n\t// upload the cropped copy to aws\n\tawsAccessKey := os.Getenv(\"AWS_ACCESS_KEY\")\n\tawsSecret := os.Getenv(\"AWS_SECRET\")\n\ttoken := \"\"\n\n\tcreds := credentials.NewStaticCredentials(awsAccessKey, awsSecret, token)\n\t_, err = creds.Get()\n\tif err != nil {\n\t\tlog.Warnf(\"cannot load aws credentials %v\", err)\n\t}\n\n\tcfg := aws.NewConfig().WithRegion(\"us-east-1\").WithCredentials(creds)\n\n\tsvc := s3.New(session.New(), cfg)\n\n\tfile, err := os.Open(pathToDir + fileName + \"_copy_conv.webp\")\n\tif err != nil {\n\t\tlog.Warnf(\"cannot open final.png to view %v\", err)\n\t}\n\tdefer func(file *os.File) {\n\t\terr := file.Close()\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"error closing image to aws -- %v\", err)\n\t\t}\n\t}(file)\n\n\tfileInfo, _ := file.Stat()\n\tvar size int64 = fileInfo.Size()\n\tbuffer = make([]byte, size)\n\tfile.Read(buffer)\n\tfileBytes := bytes.NewReader(buffer)\n\tfileType := http.DetectContentType(buffer)\n\n\tpath := \"/media/images/\" + fileName + \".webp\"\n\tparams := &s3.PutObjectInput{\n\t\tBucket:        aws.String(\"designcatalog\"),\n\t\tKey:           aws.String(path),\n\t\tBody:          fileBytes,\n\t\tContentLength: aws.Int64(size),\n\t\tContentType:   aws.String(fileType),\n\t}\n\n\tresp, err := svc.PutObject(params)\n\tif err != nil {\n\t\tlog.Warnf(\"failed to upload object to aws s3 %v\", err)\n\t}\n\tlog.Infof(\"response from aws %s\\n\", awsutil.StringValue(resp))\n\n\t// get cloudflare link\n\tcloudflareLink := os.Getenv(\"AWS_CLOUDFRONT_DIST\") + path\n\n\treturn cloudflareLink\n}\n\nfunc processPdf(teamName string, fileName string) (string, string, string, string, string) {\n\tpathToDir := \"teams/\" + teamName + \"/export/\" + \"PDF\" + \"/\"\n\n\t// this is the most common part of the png filename that is not included in the pdf file associated\n\t// so we need to remove it so the pdf can be found\n\tif strings.Contains(fileName, \"@3x\") {\n\t\tfileName = strings.ReplaceAll(fileName, \"@3x\", \"\")\n\t}\n\n\t// Exec this command to pull the string and feed it into a buffer\n\targs := []string{\n\t\t\"-layout\",                     // Maintain (as best as possible) the original physical layout of the text.\n\t\t\"-nopgbrk\",                    // Don't insert page breaks (form feed characters) between pages.\n\t\tpathToDir + fileName + \".pdf\", // The input file.\n\t\t\"-\",                           // Send the output to stdout.\n\t}\n\tcmd := exec.CommandContext(context.Background(), \"pdftotext\", args...)\n\n\tvar buf bytes.Buffer\n\tcmd.Stdout = &buf\n\n\tif err := cmd.Run(); err != nil {\n\t\tlog.Warn(err)\n\t\treturn \"\", \"\", \"\", \"\", \"\"\n\t}\n\n\t// we are moving the string into an array, so we can manipulate the extracted text\n\t// wordsArray can be searched through for things\n\twordsArray := strings.Fields(buf.String())\n\t// words is the entire string, and we are just going to return that at the end\n\twords := strings.Join(wordsArray, \" \")\n\n\t// here we are pulling out the product description, saving it as a separate field, so we can prioritize that over the rest of the text\n\tvar description []string\n\tvar sport string\n\tvar color string\n\tvar descriptionReturning string\n\tlog.Print(\"this is right before we for over the wordsArray\")\n\tfor i, v := range wordsArray {\n\t\tif v == \"DESCRIPTION:\" {\n\t\t\tif len(wordsArray) > i+5 {\n\t\t\t\tdescription = append(description, wordsArray[i+1])\n\t\t\t\tdescription = append(description, wordsArray[i+2])\n\t\t\t\tdescription = append(description, wordsArray[i+3])\n\t\t\t\tdescription = append(description, wordsArray[i+4])\n\t\t\t\tdescription = append(description, wordsArray[i+5])\n\t\t\t\tdescriptionReturning = strings.Join(description, \" \")\n\n\t\t\t\tif strings.Contains(strings.ToLower(descriptionReturning), \"baseball\") {\n\t\t\t\t\tsport = \"BASEBALL\"\n\t\t\t\t} else if strings.Contains(strings.ToLower(descriptionReturning), \"football\") {\n\t\t\t\t\tsport = \"FOOTBALL\"\n\t\t\t\t} else if strings.Contains(strings.ToLower(descriptionReturning), \"soccer\") {\n\t\t\t\t\tsport = \"SOCCER\"\n\t\t\t\t} else if strings.Contains(strings.ToLower(descriptionReturning), \"basketball\") {\n\t\t\t\t\tsport = \"BASKETBALL\"\n\t\t\t\t} else if strings.Contains(strings.ToLower(descriptionReturning), \"cheer\") {\n\t\t\t\t\tsport = \"CHEER\"\n\t\t\t\t} else if strings.Contains(strings.ToLower(descriptionReturning), \"lacrosse\") {\n\t\t\t\t\tsport = \"LACROSSE\"\n\t\t\t\t} else if strings.Contains(strings.ToLower(descriptionReturning), \"track\") {\n\t\t\t\t\tsport = \"TRACK_AND_FIELD\"\n\t\t\t\t} else if strings.Contains(strings.ToLower(descriptionReturning), \"outdoor\") {\n\t\t\t\t\tsport = \"OUTDOOR\"\n\t\t\t\t} else if strings.Contains(strings.ToLower(descriptionReturning), \"volleyball\") {\n\t\t\t\t\tsport = \"VOLLEYBALL\"\n\t\t\t\t} else if strings.Contains(strings.ToLower(descriptionReturning), \"hockey\") {\n\t\t\t\t\tsport = \"HOCKEY\"\n\t\t\t\t} else if strings.Contains(strings.ToLower(descriptionReturning), \"fishing\") {\n\t\t\t\t\tsport = \"FISHING\"\n\t\t\t\t} else if strings.Contains(strings.ToLower(descriptionReturning), \"shooting\") {\n\t\t\t\t\tsport = \"ARCHERY_AND_SHOOTING_SPORTS\"\n\t\t\t\t} else if strings.Contains(strings.ToLower(descriptionReturning), \"classic\") {\n\t\t\t\t\tsport = \"CORE\"\n\t\t\t\t} else if strings.Contains(strings.ToLower(descriptionReturning), \"compression\") {\n\t\t\t\t\tsport = \"COMPRESSIONS\"\n\t\t\t\t} else if strings.Contains(strings.ToLower(descriptionReturning), \"hat\") {\n\t\t\t\t\tsport = \"HATS\"\n\t\t\t\t} else if strings.Contains(strings.ToLower(descriptionReturning), \"band\") {\n\t\t\t\t\tsport = \"MARCHING_BAND\"\n\t\t\t\t} else if strings.Contains(strings.ToLower(descriptionReturning), \"wrestle\") {\n\t\t\t\t\tsport = \"WRESTLING\"\n\t\t\t\t} else if strings.Contains(strings.ToLower(descriptionReturning), \"rugby\") {\n\t\t\t\t\tsport = \"RUGBY\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// find used colors / colors used and grab like 5 words after, trying to get the main colors chosen\n\t// my start point is either 'used colors' 'colors used' 'usedcolors' 'colorsused'\n\tvar colorIndexStarting int\n\tlog.Print(\"this is right before we for over the wordsArray the second time\")\n\tfor i := range wordsArray {\n\t\tfirstWord := strings.ToLower(wordsArray[i])\n\t\tvar secondWord string\n\t\tif i+1 < len(wordsArray) {\n\t\t\tsecondWord = strings.ToLower(wordsArray[i+1])\n\t\t} else {\n\t\t\tsecondWord = \"-\"\n\t\t}\n\n\t\tif firstWord == \"used\" && secondWord == \"colors:\" {\n\t\t\tcolorIndexStarting = i + 2\n\t\t} else if firstWord == \"used\" && secondWord == \"colors\" {\n\t\t\tcolorIndexStarting = i + 2\n\t\t} else if firstWord == \"colors\" && secondWord == \"used:\" {\n\t\t\tcolorIndexStarting = i + 2\n\t\t} else if firstWord == \"colors\" && secondWord == \"used\" {\n\t\t\tcolorIndexStarting = i + 2\n\t\t} else if firstWord == \"usedcolors:\" || firstWord == \"usedcolors\" {\n\t\t\tcolorIndexStarting = i + 1\n\t\t} else if firstWord == \"colorsused:\" || firstWord == \"colorsused\" {\n\t\t\tcolorIndexStarting = i + 1\n\t\t}\n\t}\n\n\tlog.Print(\"this is right before we append on the colors\")\n\tvar colors []string\n\tif len(wordsArray) > colorIndexStarting+7 {\n\t\t// grab an array of the colors from that starting point\n\t\tcolors = append(colors, wordsArray[colorIndexStarting])\n\t\tcolors = append(colors, wordsArray[colorIndexStarting+1])\n\t\tcolors = append(colors, wordsArray[colorIndexStarting+2])\n\t\tcolors = append(colors, wordsArray[colorIndexStarting+3])\n\t\tcolors = append(colors, wordsArray[colorIndexStarting+4])\n\t\tcolors = append(colors, wordsArray[colorIndexStarting+5])\n\t\tcolors = append(colors, wordsArray[colorIndexStarting+6])\n\t\tcolors = append(colors, wordsArray[colorIndexStarting+7])\n\n\t\tcolor = strings.Join(colors, \" \")\n\t}\n\tlog.Print(\"this is right AFTER we append on the colors\")\n\n\t// upload the pdf to aws\n\tawsAccessKey := os.Getenv(\"AWS_ACCESS_KEY\")\n\tawsSecret := os.Getenv(\"AWS_SECRET\")\n\ttoken := \"\"\n\n\tcreds := credentials.NewStaticCredentials(awsAccessKey, awsSecret, token)\n\t_, err := creds.Get()\n\tif err != nil {\n\t\tlog.Warnf(\"cannot load aws credentials %v\", err)\n\t}\n\n\tcfg := aws.NewConfig().WithRegion(\"us-east-1\").WithCredentials(creds)\n\n\tsvc := s3.New(session.New(), cfg)\n\n\tfile, err := os.Open(pathToDir + fileName + \".pdf\")\n\tif err != nil {\n\t\tlog.Warnf(\"cannot open final.pdf to view %v\", err)\n\t}\n\tdefer func(file *os.File) {\n\t\terr := file.Close()\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"error closing image to aws -- %v\", err)\n\t\t}\n\t}(file)\n\n\tfileInfo, _ := file.Stat()\n\tvar size int64 = fileInfo.Size()\n\tbuffer := make([]byte, size)\n\tfile.Read(buffer)\n\tfileBytes := bytes.NewReader(buffer)\n\tfileType := http.DetectContentType(buffer)\n\n\tpath := \"/media/pdfs/\" + fileName + \".pdf\"\n\tparams := &s3.PutObjectInput{\n\t\tBucket:        aws.String(\"designcatalog\"),\n\t\tKey:           aws.String(path),\n\t\tBody:          fileBytes,\n\t\tContentLength: aws.Int64(size),\n\t\tContentType:   aws.String(fileType),\n\t}\n\n\tresp, err := svc.PutObject(params)\n\tif err != nil {\n\t\tlog.Warnf(\"failed to upload object to aws s3 %v\", err)\n\t}\n\tlog.Infof(\"response from aws %s\\n\", awsutil.StringValue(resp))\n\n\t// get cloudflare link\n\tcloudflareLink := os.Getenv(\"AWS_CLOUDFRONT_DIST\") + path\n\n\treturn cloudflareLink, words, descriptionReturning, sport, color\n}\n\nfunc processPngFull(teamName string, parentDirName string, fileName string) string {\n\tpathToDir := \"teams/\" + teamName + \"/export/\" + parentDirName + \"/\"\n\n\t// crop and process (compress) the png ============================================= //\n\togImageFile, err := os.Open(pathToDir + fileName + \".png\")\n\tif err != nil {\n\t\tlog.Warn(err)\n\t}\n\tdefer func(ogImageFile *os.File) {\n\t\terr := ogImageFile.Close()\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"error decoding og image -- %v\", err)\n\t\t}\n\t}(ogImageFile)\n\n\tawsAccessKey := os.Getenv(\"AWS_ACCESS_KEY\")\n\tawsSecret := os.Getenv(\"AWS_SECRET\")\n\ttoken := \"\"\n\n\tcreds := credentials.NewStaticCredentials(awsAccessKey, awsSecret, token)\n\t_, err = creds.Get()\n\tif err != nil {\n\t\tlog.Warnf(\"cannot load aws credentials %v\", err)\n\t}\n\n\tcfg := aws.NewConfig().WithRegion(\"us-east-1\").WithCredentials(creds)\n\n\tsvc := s3.New(session.New(), cfg)\n\n\tfileInfo, _ := ogImageFile.Stat()\n\tvar size int64 = fileInfo.Size()\n\tbuffer := make([]byte, size)\n\togImageFile.Read(buffer)\n\tfileBytes := bytes.NewReader(buffer)\n\tfileType := http.DetectContentType(buffer)\n\n\tpath := \"/media/images/\" + fileName + \"full.webp\"\n\tparams := &s3.PutObjectInput{\n\t\tBucket:        aws.String(\"designcatalog\"),\n\t\tKey:           aws.String(path),\n\t\tBody:          fileBytes,\n\t\tContentLength: aws.Int64(size),\n\t\tContentType:   aws.String(fileType),\n\t}\n\n\tresp, err := svc.PutObject(params)\n\tif err != nil {\n\t\tlog.Warnf(\"failed to upload object to aws s3 %v\", err)\n\t}\n\tlog.Infof(\"response from aws %s\\n\", awsutil.StringValue(resp))\n\n\t// get cloudflare link\n\tcloudflareLink := os.Getenv(\"AWS_CLOUDFRONT_DIST\") + path\n\n\treturn cloudflareLink\n}\n\nfunc processAi(teamName string, fileName string) string {\n\tpathToDir := \"teams/\" + teamName + \"/\"\n\n\tinputFile := pathToDir + fileName + \".ai\" // The input file.\n\n\t// upload the ai to aws\n\tawsAccessKey := os.Getenv(\"AWS_ACCESS_KEY\")\n\tawsSecret := os.Getenv(\"AWS_SECRET\")\n\ttoken := \"\"\n\n\tcreds := credentials.NewStaticCredentials(awsAccessKey, awsSecret, token)\n\t_, err := creds.Get()\n\tif err != nil {\n\t\tlog.Warnf(\"cannot load aws credentials %v\", err)\n\t}\n\n\tcfg := aws.NewConfig().WithRegion(\"us-east-1\").WithCredentials(creds)\n\n\tsvc := s3.New(session.New(), cfg)\n\n\tfile, err := os.Open(inputFile)\n\tif err != nil {\n\t\tlog.Warnf(\"cannot open final.pdf to view %v\", err)\n\t}\n\tdefer func(file *os.File) {\n\t\terr := file.Close()\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"error closing image to aws -- %v\", err)\n\t\t}\n\t}(file)\n\n\tfileInfo, _ := file.Stat()\n\tvar size int64 = fileInfo.Size()\n\tbuffer := make([]byte, size)\n\tfile.Read(buffer)\n\tfileBytes := bytes.NewReader(buffer)\n\tfileType := http.DetectContentType(buffer)\n\n\trandomInt := rand.IntN(10000)\n\tpath := \"/media/ai/\" + teamName + fileName + string(randomInt) + \".ai\"\n\tparams := &s3.PutObjectInput{\n\t\tBucket:        aws.String(\"designcatalog\"),\n\t\tKey:           aws.String(path),\n\t\tBody:          fileBytes,\n\t\tContentLength: aws.Int64(size),\n\t\tContentType:   aws.String(fileType),\n\t}\n\n\tresp, err := svc.PutObject(params)\n\tif err != nil {\n\t\tlog.Warnf(\"failed to upload object to aws s3 %v\", err)\n\t}\n\tlog.Infof(\"response from aws %s\\n\", awsutil.StringValue(resp))\n\n\t// get cloudflare link\n\tcloudflareLink := os.Getenv(\"AWS_CLOUDFRONT_DIST\") + path\n\n\treturn cloudflareLink\n}\n\nfunc uploadDesignEntry(fileName string, text string, description string, pngCdn string, pdfCdn string, sport string, color string, aiCdn string, teamId int, pngCdnFull string) {\n\ttags := []string{}\n\n\tdesignEntry := models.DesignEntry{\n\t\tTitle:         fileName,\n\t\tDescription:   description,\n\t\tCFLinkPNG:     pngCdn,\n\t\tCFLinkPDF:     pdfCdn,\n\t\tTextFromImage: strings.ToLower(text),\n\t\tTags:          pq.StringArray(tags),\n\t\tSport:         sport,\n\t\tColor:         color,\n\t\tCFLinkAI:      aiCdn,\n\t\tTeamID:        teamId,\n\t\tCFLinkPNGFull: pngCdnFull,\n\t}\n\n\t// was the old create -- result := inits.DB.Create(&designEntry)\n\t// this new first or create returns the record if it exists, and creates it if it doesnt\n\tresult := inits.DB.FirstOrCreate(&designEntry, models.DesignEntry{Title: fileName})\n\tif result.Error != nil {\n\t\tlog.Warnf(\"failed to upload object to postgres database %v\", result.Error)\n\t}\n}\n```\nand tell me a few ways I could clean it up? It's not erroring at all, I just want to make the code cleaner\nCertainly! Here are several ways you could clean up and improve the code:\n\n1. Modularize the code:\n   - Break down the main function into smaller, more focused functions.\n   - Create separate functions for processing teams, directories, and files.\n\n2. Use constants for repeated strings and magic numbers:\n   - Define constants for frequently used strings like file extensions and folder names.\n   - Replace magic numbers (e.g., 1913, 1240, 19, 250) with named constants.\n\n3. Improve error handling:\n   - Instead of just logging errors, consider returning them and handling them at a higher level.\n   - Use custom error types for better error categorization.\n\n4. Use a configuration file:\n   - Move hardcoded values (like AWS region, bucket names) to a configuration file.\n\n5. Implement interfaces for external services:\n   - Create interfaces for AWS S3 and database operations to improve testability.\n\n6. Use a more robust logging solution:\n   - Consider using a structured logging library like zap or logrus.\n\n7. Improve variable naming:\n   - Use more descriptive names for variables like 'v', 'i', etc.\n\n8. Use string builders for string concatenation:\n   - Replace multiple string additions with strings.Builder for better performance.\n\n9. Utilize goroutines for concurrent processing:\n   - Process multiple files or teams concurrently using goroutines and channels.\n\n10. Implement a more robust CLI:\n    - Use a CLI library like cobra to provide a better command-line interface.\n\n11. Use context for better resource management:\n    - Pass context through functions to allow for better cancellation and timeout handling.\n\n12. Improve file type detection:\n    - Instead of relying on file extensions, use a library like filetype to determine file types.\n\n13. Use dependency injection:\n    - Pass dependencies (like database connections) to functions instead of using global variables.\n\n14. Implement unit tests:\n    - Add unit tests for individual functions to improve code reliability.\n\n15. Use linters:\n    - Run tools like golangci-lint to catch potential issues and enforce consistent style.\n\nThese suggestions can help make your code more maintainable, efficient, and easier to understand. Implement them gradually, focusing on the areas that will provide the most benefit for your specific use case.\nWhat of those changes should I start with, and why?\nGiven the current state of your code, I'd recommend starting with these changes, in order of priority:\n\n1. Modularize the code:\n   Why: Your main function is very long and handles multiple responsibilities. Breaking it down will immediately improve readability and maintainability.\n   How: Start by extracting the team processing logic, file processing logic, and upload logic into separate functions.\n\n2. Use constants for repeated strings and magic numbers:\n   Why: This will make your code more readable and easier to maintain. It reduces the risk of typos and makes it easier to update values in one place.\n   How: Define constants for file extensions, folder names, and numeric values used in image processing.\n\n3. Improve error handling:\n   Why: Your current approach of logging errors but continuing execution could lead to unexpected behavior. Better error handling will make your program more robust.\n   How: Return errors from functions and handle them at a higher level. Consider how to gracefully handle different types of errors.\n\n4. Use a configuration file:\n   Why: This separates configuration from code, making it easier to deploy your application in different environments without changing the code.\n   How: Create a config.yaml or config.json file and use a library like Viper to load it.\n\n5. Improve variable naming:\n   Why: This is a quick win that will immediately make your code more readable.\n   How: Replace short variable names like 'v' and 'i' with more descriptive names.\n\nHere's why I recommend this order:\n\n1. Modularizing the code will give you the biggest immediate benefit in terms of code organization and readability. It's also a prerequisite for many other improvements.\n\n2. Using constants is a relatively easy change that will make your code more maintainable right away.\n\n3. Improving error handling is crucial for the reliability of your application, and it's better to implement this early before adding more complexity.\n\n4. A configuration file will make your application more flexible and easier to deploy, which is important as your project grows.\n\n5. Improving variable naming is a quick win that you can do alongside the other changes.\n\nThese initial changes will set a good foundation for further improvements. They'll make your code more readable, maintainable, and robust, which will make it easier to implement some of the more advanced suggestions later on.\nWill these changes affect the speed of the application? Or just make it more scalable and maintainable?\nGreat question! Let's break down how these initial changes are likely to impact your application:\n\n1. Modularizing the code:\n   - Performance impact: Negligible to slight positive\n   - This might lead to a very small performance improvement due to better cache utilization, but the difference is usually negligible.\n   - It doesn't directly improve speed but makes the code more maintainable and easier to optimize later.\n\n2. Using constants for repeated strings and magic numbers:\n   - Performance impact: Negligible\n   - This change is primarily for readability and maintainability. Modern compilers optimize these effectively, so there's typically no performance difference.\n\n3. Improving error handling:\n   - Performance impact: Slight negative to negligible\n   - Proper error handling might introduce a tiny overhead, but it's usually insignificant compared to the benefits of more robust code.\n\n4. Using a configuration file:\n   - Performance impact: Slight negative (only at startup)\n   - Reading from a config file adds a small overhead at application startup, but it's typically negligible during runtime.\n\n5. Improving variable naming:\n   - Performance impact: None\n   - This is purely a readability improvement with no impact on performance.\n\nOverall, these changes are primarily aimed at improving maintainability, scalability, and robustness rather than speed. The performance impact, if any, would be minimal and likely unnoticeable in most cases.\n\nHowever, these changes lay the groundwork for potential performance improvements:\n\n1. Modular code is easier to profile and optimize.\n2. Better error handling can prevent unnecessary processing of invalid data.\n3. A configuration file allows for easy tuning of performance-related parameters.\n\nIf you're looking to improve speed specifically, you might want to consider:\n\n1. Implementing concurrency with goroutines for parallel processing of files or teams.\n2. Optimizing I/O operations, especially when dealing with large files.\n3. Using more efficient data structures or algorithms where appropriate.\n4. Profiling your application to identify bottlenecks.\n\nRemember, premature optimization can lead to more complex, harder-to-maintain code. It's often better to focus on clean, correct code first, then optimize for performance where necessary based on profiling results.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":136}},"image_offsets":[]},{"id":{"replica_id":0,"value":21},"start":20645,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":137}},"image_offsets":[]},{"id":{"replica_id":0,"value":22},"start":22955,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":138}},"image_offsets":[]},{"id":{"replica_id":0,"value":64},"start":23007,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":139}},"image_offsets":[]},{"id":{"replica_id":0,"value":65},"start":25416,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":140}},"image_offsets":[]},{"id":{"replica_id":0,"value":124},"start":25520,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":141}},"image_offsets":[]},{"id":{"replica_id":0,"value":125},"start":27858,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":142}},"image_offsets":[]}],"summary":"Go code cleanup and optimization suggestions","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default"},{"range":{"start":31,"end":20537},"icon":"File","label":"silverbadger/main.go"}]}